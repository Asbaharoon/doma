============
Criteria API
============

.. contents::
   :depth: 4

.. warning::

    The criteria API is an experimental feature.

Introduction
============

There are two kind of DSLs in the Criteria API:

* The Entityql DSL
* The NativeSql DSL

Both require predefined Entity classes and the meta classes generated by Doma's annotation processors.

We use the following Entity classes to show you some examples:

.. code-block:: java

    @Entity
    public class Employee {

      @Id private Integer employeeId;
      private Integer employeeNo;
      private String employeeName;
      private Integer managerId;
      private LocalDate hiredate;
      private Salary salary;
      private Integer departmentId;
      private Integer addressId;
      @Version private Integer version;
      @OriginalStates private Employee states;
      @Transient private Department department;
      @Transient private Employee manager;
      @Transient private Address address;

      // getter and setter
    }

.. code-block:: java

    @Entity
    public class Department {

      @Id private Integer departmentId;
      private Integer departmentNo;
      private String departmentName;
      private String location;
      @Version private Integer version;
      @OriginalStates private Department originalStates;
      @Transient private List<Employee> employeeList = new ArrayList<>();

      // getter and setter
    }

Each of the above classes has a corresponding meta class - ``Employee_`` and ``Department_``.
These meta classes allow you to make your query typesafe.

You can customize the name of the meta classes by specifying annotation processor options.
See :doc:`annotation-processing` and check the `doma.criteria.prefix`
and the `doma.criteria.suffix` options.

Entityql DSL
------------

The Entityql DSL can query and associate entities.
The entry point is the ``org.seasar.doma.jdbc.criteria.Entityql`` class.
This class has the following methods:

* from
* insert
* delete
* update

You can instantiate the ``Entityql`` class as follows:

.. code-block:: java

    Entityql entityql = new Entityql(config);

For example, to query ``Employee`` and ``Department`` entities and associate them, write as follows:

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Employee> list =
        entityql
            .from(e)
            .innerJoin(d, on -> on.eq(e.departmentId, d.departmentId))
            .where(c -> c.eq(d.departmentName, "SALES"))
            .associate(
                e,
                d,
                (employee, department) -> {
                  employee.setDepartment(department);
                  department.getEmployeeList().add(employee);
                })
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID,
    t0_.HIREDATE, t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION,
    t1_.DEPARTMENT_ID, t1_.DEPARTMENT_NO, t1_.DEPARTMENT_NAME, t1_.LOCATION, t1_.VERSION
    from EMPLOYEE t0_ inner join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)
    where t1_.DEPARTMENT_NAME = ?

NativeSql DSL
-------------

The NativeSql DSL can issue more complex SQL statements rather than the Entityql DSL.
But note that the NativeSql DSL doesn't support to associate entities.

The entry point is the ``org.seasar.doma.jdbc.criteria.NativeSql`` class.
This class has the following methods:

* from
* delete
* insert
* update

You can use instantiate the ``NativeSql`` class as follows:

.. code-block:: java

    NativeSql nativeSql = new NativeSql(config);

For example, to query two columns with GROUP BY and HAVING clauses, write as follows:

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Tuple2<Long, String>> list =
        nativeSql
            .from(e)
            .innerJoin(d, on -> on.eq(e.departmentId, d.departmentId))
            .groupBy(d.departmentName)
            .having(c -> c.gt(count(), 3L))
            .orderBy(c -> c.asc(count()))
            .select(count(), d.departmentName)
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select count(*), t1_.DEPARTMENT_NAME from EMPLOYEE t0_
    inner join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)
    group by t1_.DEPARTMENT_NAME
    having count(*) > ?
    order by count(*) asc

Select statement
================

Select settings (Entityql, NativeSql)
-------------------------------------

We support the following settings:

* comment
* queryTimeout
* sqlLogType
* fetchSize
* maxRows

They are all optional.
You can apply them as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list = entityql.from(e, settings -> {
      settings.setComment("all employees");
      settings.setSqlLogType(SqlLogType.RAW);
      settings.setQueryTimeout(1000);
      settings.setFetchSize(100);
      settings.setMaxRows(100);
    }).fetch();

Fetching (Entityql, NativeSql)
------------------------------

Both Entityql DSL and NativeSql DSL support the following methods to fetch data from a database:

* fetch
* fetchOne
* fetchOptional
* stream

.. code-block:: java

    Employee_ e = new Employee_();

    // The fetch method returns results as list.
    List<Employee> list =
        entityql.from(e).fetch();

    // The fetchOne method returns a single result. The result may be null.
    Employee employee =
        entityql.from(e).where(c -> c.eq(e.employeeId, 1)).fetchOne();

    // The fetchOptional method returns a single result as an optional object.
    Optional<Employee> optional =
        entityql.from(e).where(c -> c.eq(e.employeeId, 1)).fetchOptional();

    // The stream method returns results as a stream.
    // The following code is equivalent to "entityql.from(e).fetch().stream()"
    Stream<Employee> stream =
        entityql.from(e).stream();

Streaming (NativeSql)
---------------------

The NativeSql Dsl supports the following methods:

* mapStream
* collect

.. code-block:: java

    Employee_ e = new Employee_();

    // The mapStream method handles a stream.
    Map<Integer, List<Employee>> map =
        nativeSql
            .from(e)
            .mapStream(stream -> stream.collect(groupingBy(Employee::getDepartmentId)));

    // The collect method is a shortcut of the mapStream method.
    // The following code does the same thing with the above.
    Map<Integer, List<Employee>> map2 =
        nativeSql.from(e).collect(groupingBy(Employee::getDepartmentId));

These methods handle the stream that wraps a JDBC ResultSet.
So they are useful to process a large ResultSet effectively.

Select expression (NativeSql)
-----------------------------

To project columns, use the select method.

To project one column, pass one property to the select method as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    List<String> list = nativeSql.from(e).select(e.employeeName).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_NAME from EMPLOYEE t0_

To project two or more columns, pass two or more properties to the select method as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    List<Tuple2<String, Integer>> list =
        nativeSql.from(e).select(e.employeeName, e.employeeNo).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_NAME, t0_.EMPLOYEE_NO from EMPLOYEE t0_

Up to 9 numbers, the column results are held by ``Tuple2`` to ``Tuple9``.
For more than 9 numbers, the results are held by ``List<Object>``.

.. _criteria_where:

Where expression (Entityql, NativeSql)
--------------------------------------

We support the following operators and predicates:

* eq - (=)
* ne - (<>)
* ge - (>=)
* gt - (>)
* le - (<=)
* lt - (<)
* isNull - (is null)
* isNotNull - (is not null)
* like
* notLike - (not like)
* between
* in
* notIn - (not in)
* exists
* notExists - (not exists)

We also support the following logical operators:

* and
* or
* not

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list =
        entityql
            .from(e)
            .where(
                c -> {
                  c.eq(e.departmentId, 2);
                  c.isNotNull(e.managerId);
                  c.or(
                      () -> {
                        c.gt(e.salary, new Salary("1000"));
                        c.lt(e.salary, new Salary("2000"));
                      });
                })
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    where t0_.DEPARTMENT_ID = ? and t0_.MANAGER_ID is not null or (t0_.SALARY > ? and t0_.SALARY < ?)

You can write a subquery as follows:

.. code-block:: java

    Employee_ e = new Employee_();
    Employee_ e2 = new Employee_();

    List<Employee> list =
        entityql
            .from(e)
            .where(c -> c.in(e.employeeId, c.from(e2).select(e2.managerId)))
            .orderBy(c -> c.asc(e.employeeId))
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    where t0_.EMPLOYEE_ID in (select t1_.MANAGER_ID from EMPLOYEE t1_)
    order by t0_.EMPLOYEE_ID asc

Dynamic where expression (Entityql, NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A where expression uses only evaluated operators to build a WHERE clause.

When every operators are not evaluated in a where expression,
the built statement doesn't have any WHERE clause.

As well as, when every operators are not evaluated in a logical operator expression,
the built statement doesn't have the logical operator expression.

For example, suppose that a where expression contains a conditional expression as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list =
        entityql
            .from(e)
            .where(
                c -> {
                  c.eq(e.departmentId, 1);
                  if (name != null) {
                    c.like(e.employeeName, name);
                  }
                })
            .fetch();

In the case that the ``name`` variable is ``null``, the ``like`` expression is ignored.
The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_ where t0_.DEPARTMENT_ID = ?

Join expression
---------------

We support the following expressions:

- innerJoin - (inner join)
- leftJoin - (left outer join)

innerJoin (Entityql, NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Employee> list =
        entityql.from(e).innerJoin(d, on -> on.eq(e.departmentId, d.departmentId)).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    inner join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)

leftJoin (Entityql, NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Employee> list =
        entityql.from(e).leftJoin(d, on -> on.eq(e.departmentId, d.departmentId)).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    left outer join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)

.. _criteria_associate:

associate (Entityql)
~~~~~~~~~~~~~~~~~~~~

You can associate entities with the ``associate`` operation in the Entityql DSL.
You have to use the ``associate`` operation with join expression.

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Employee> list =
        entityql
            .from(e)
            .innerJoin(d, on -> on.eq(e.departmentId, d.departmentId))
            .where(c -> c.eq(d.departmentName, "SALES"))
            .associate(
                e,
                d,
                (employee, department) -> {
                  employee.setDepartment(department);
                  department.getEmployeeList().add(employee);
                })
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID,
    t0_.HIREDATE, t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION,
    t1_.DEPARTMENT_ID, t1_.DEPARTMENT_NO, t1_.DEPARTMENT_NAME, t1_.LOCATION, t1_.VERSION
    from EMPLOYEE t0_ inner join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)
    where t1_.DEPARTMENT_NAME = ?

You can associate many entities:

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();
    Address_ a = new Address_();

    List<Employee> list =
        entityql
            .from(e)
            .innerJoin(d, on -> on.eq(e.departmentId, d.departmentId))
            .innerJoin(a, on -> on.eq(e.addressId, a.addressId))
            .where(c -> c.eq(d.departmentName, "SALES"))
            .associate(
                e,
                d,
                (employee, department) -> {
                  employee.setDepartment(department);
                  department.getEmployeeList().add(employee);
                })
            .associate(e, a, Employee::setAddress)
            .fetch();

Dynamic join expression (Entityql, NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A join expression uses only evaluated operators to build a JOIN clause.

When every operators are not evaluated in a join expression,
the built statement doesn't have any JOIN clause.

For example, suppose that a join expression contains a conditional expression as follows:

.. code-block:: java

    Employee_ e = new Employee_();
    Employee_ e2 = new Employee_();

    List<Employee> list =
        entityql
            .from(e)
            .innerJoin(
                e2,
                on -> {
                  if (join) {
                    on.eq(e.managerId, e2.employeeId);
                  }
                })
            .fetch();

In the case that the ``join`` variable is ``false``, the ``on`` expression is ignored.
The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_

Dynamic associate (Entityql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you use the above dynamic join expression, the association must be optional.
To do it, pass ``AssociationOption.OPTIONAL`` to the associate method:

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Employee> list =
        entityql
            .from(e)
            .innerJoin(
                d,
                on -> {
                  if (join) {
                    on.eq(e.departmentId, d.departmentId);
                  }
                })
            .associate(
                e,
                d,
                (employee, department) -> {
                  employee.setDepartment(department);
                  department.getEmployeeList().add(employee);
                },
                AssociationOption.OPTIONAL)
            .fetch();

Aggregate Functions (NativeSql)
-------------------------------

We support the following aggregate functions:

* avg(property)
* count()
* count(property)
* max(property)
* min(property)
* sum(property)

These are defined in the ``org.seasar.doma.jdbc.criteria.AggregateFunctions`` class.
Use them with static import.

For example, you can pass the ``sum`` function to the select method:

.. code-block:: java

    Employee_ e = new Employee_();

    Salary salary = nativeSql.from(e).select(sum(e.salary)).fetchOne();

The above query issues the following SQL statement:

.. code-block:: sql

    select sum(t0_.SALARY) from EMPLOYEE t0_

Group by expression (NativeSql)
-------------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    List<Tuple2<Integer, Long>> list =
        nativeSql.from(e).groupBy(e.departmentId).select(e.departmentId, count()).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.DEPARTMENT_ID, count(*) from EMPLOYEE t0_ group by t0_.DEPARTMENT_ID

When you don't specify a group by expression,
the expression is inferred from the select expression automatically.
So the following code issue the same SQL statement above:

.. code-block:: java

    Employee_ e = new Employee_();

    List<Tuple2<Integer, Long>> list =
        nativeSql.from(e).select(e.departmentId, count()).fetch();

Having expression (NativeSql)
-----------------------------

We support the following operators:

* eq - (=)
* ne - (<>)
* ge - (>=)
* gt - (>)
* le - (<=)
* lt - (<)

We also support the following logical operators:

* and
* or
* not

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Tuple2<Long, String>> list =
        nativeSql
            .from(e)
            .innerJoin(d, on -> on.eq(e.departmentId, d.departmentId))
            .having(c -> c.gt(count(), 3L))
            .orderBy(c -> c.asc(count()))
            .select(count(), d.departmentName)
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select count(*), t1_.DEPARTMENT_NAME
    from EMPLOYEE t0_
    inner join DEPARTMENT t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)
    group by t1_.DEPARTMENT_NAME having count(*) > ? or (min(t0_.SALARY) <= ?)
    order by count(*) asc

Dynamic having expression (NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A having expression uses only evaluated operators to build a HAVING clause.

When every operators are not evaluated in a having expression,
the built statement doesn't have any HAVING clause.

As well as, when every operators are not evaluated in a logical operator expression,
the built statement doesn't have the logical operator expression.

Order by expression (Entityql, NativeSql)
-----------------------------------------

We support the following order operations:

* asc
* desc

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list =
        entityql
            .from(e)
            .orderBy(
                c -> {
                  c.asc(e.departmentId);
                  c.desc(e.salary);
                })
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    order by t0_.DEPARTMENT_ID asc, t0_.SALARY desc

Dynamic order by expression (NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

An order by expression uses only evaluated operators to build an ORDER BY clause.

When every operators are not evaluated in a order by expression,
the built statement doesn't have any ORDER BY clause.

Distinct expression (Entityql, NativeSql)
-----------------------------------------

.. code-block:: java

    List<Department> list =
            nativeSql
                    .from(d)
                    .distinct()
                    .leftJoin(e, on -> on.eq(d.departmentId, e.departmentId))
                    .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select distinct t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME,
    t0_.LOCATION, t0_.VERSION
    from DEPARTMENT t0_
    left outer join EMPLOYEE t1_ on (t0_.DEPARTMENT_ID = t1_.DEPARTMENT_ID)

Limit and Offset expression (Entityql, NativeSql)
-------------------------------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list =
        nativeSql.from(e).limit(5).offset(3).orderBy(c -> c.asc(e.employeeNo)).fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    order by t0_.EMPLOYEE_NO asc
    limit 5 offset 3

Dynamic Limit and Offset expression (Entityql, NativeSql)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A limit expressions uses only non-null value to build a LIMIT clause.
When the value is null ,the built statement doesn't have any LIMIT clause.

As well as, an offset expressions uses only non-null value to build a OFFSET clause.
When the value is null ,the built statement doesn't have any OFFSET clause.

For Update expression (Entityql, NativeSql)
-------------------------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> list = nativeSql.from(e).where(c -> c.eq(e.employeeId, 1)).forUpdate().fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NO, t0_.EMPLOYEE_NAME, t0_.MANAGER_ID, t0_.HIREDATE,
    t0_.SALARY, t0_.DEPARTMENT_ID, t0_.ADDRESS_ID, t0_.VERSION
    from EMPLOYEE t0_
    where t0_.EMPLOYEE_ID = ?
    for update

Union expression (NativeSql)
----------------------------

We support the following expressions:

- union
- unionAll - (union all)

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Tuple2<Integer, String>> list =
        nativeSql
            .from(e)
            .select(e.employeeId, e.employeeName)
            .union(nativeSql.from(d)
            .select(d.departmentId, d.departmentName))
            .fetch();

The above query issues the following SQL statement:

.. code-block:: sql

    select t0_.EMPLOYEE_ID, t0_.EMPLOYEE_NAME from EMPLOYEE t0_
    union
    select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NAME from DEPARTMENT t0_

The order by expression with index is supported:

.. code-block:: java

    Employee_ e = new Employee_();
    Department_ d = new Department_();

    List<Tuple2<Integer, String>> list =
        nativeSql
            .from(e)
            .select(e.employeeId, e.employeeName)
            .union(nativeSql.from(d)
            .select(d.departmentId, d.departmentName))
            .orderBy(c -> c.asc(2))
            .fetch();

Delete statement
============================

For the specification of the where expression, see :ref:`criteria_where`.
The same rule is applied to delete statements.

Delete settings (Entityql, NativeSql)
-------------------------------------

We support the following settings:

* comment
* queryTimeout
* sqlLogType
* allowEmptyWhere
* batchSize

They are all optional.

You can apply them as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    int count = nativeSql.delete(e, settings -> {
      settings.setComment("delete all");
      settings.setQueryTimeout(1000);
      settings.setSqlLogType(SqlLogType.RAW);
      settings.setAllowEmptyWhere(true);
      settings.setBatchSize(20);
    }).execute();

.. note::

    If you want to build a delete statement without a WHERE clause,
    you have to enable the `allowEmptyWhere` setting.

Delete statement (Entityql)
---------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    Employee employee = entityql.from(e).where(c -> c.eq(e.employeeId, 5)).fetchOne();

    Employee result = entityql.delete(e, employee).execute();

The above query issues the following SQL statement:

.. code-block:: sql

    delete from EMPLOYEE where EMPLOYEE_ID = ? and VERSION = ?

Batch Delete is also supported:

.. code-block:: java

    Employee_ e = new Employee_();

    List<Employee> employees =
        entityql.from(e).where(c -> c.in(e.employeeId, Arrays.asList(5, 6))).fetch();

    List<Employee> results = entityql.delete(e, employees).execute();

The execute method may throw following exceptions:

* OptimisticLockException: if the entity has a version property and an update count is 0

Delete statement (NativeSql)
----------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    int count = nativeSql.delete(e).where(c -> c.ge(e.salary, new Salary("2000"))).execute();

The above query issues the following SQL statement:

.. code-block:: sql

    delete from EMPLOYEE t0_ where t0_.SALARY >= ?

Insert statement
============================

Insert settings (Entityql, NativeSql)
-------------------------------------

We support the following settings:

* comment
* queryTimeout
* sqlLogType
* batchSize

They are all optional.

You can apply them as follows:

.. code-block:: java

    int count =
        nativeSql
            .insert(d, settings -> {
                settings.setComment("insert department");
                settings.setQueryTimeout(1000);
                settings.setSqlLogType(SqlLogType.RAW);
                settings.setBatchSize(20);
            })
            .values(
                c -> {
                  c.value(d.departmentId, 99);
                  c.value(d.departmentNo, 99);
                  c.value(d.departmentName, "aaa");
                  c.value(d.location, "bbb");
                  c.value(d.version, 1);
                })
            .execute();

Insert statement (Entityql)
----------------------------

.. code-block:: java

    Department_ d = new Department_();

    Department department = new Department();
    department.setDepartmentId(99);
    department.setDepartmentNo(99);
    department.setDepartmentName("aaa");
    department.setLocation("bbb");

    Department result = entityql.insert(d, department).execute();

The above query issues the following SQL statement:

.. code-block:: sql

    insert into DEPARTMENT (DEPARTMENT_ID, DEPARTMENT_NO, DEPARTMENT_NAME, LOCATION, VERSION)
    values (?, ?, ?, ?, ?)

Batch Insert is also supported:

.. code-block:: java

    Department_ d = new Department_();

    Department department = ...;
    Department department2 = ...;
    List<Department> departments = Arrays.asList(department, department2);

    List<Department> results = entityql.insert(d, departments).execute();

The execute method may throw following exceptions:

* UniqueConstraintException: if an unique constraint is violated

Insert statement (NativeSql)
----------------------------

.. code-block:: java

    Department_ d = new Department_();

    int count =
        nativeSql
            .insert(d)
            .values(
                c -> {
                  c.value(d.departmentId, 99);
                  c.value(d.departmentNo, 99);
                  c.value(d.departmentName, "aaa");
                  c.value(d.location, "bbb");
                  c.value(d.version, 1);
                })
            .execute();

The above query issues the following SQL statement:

.. code-block:: sql

    insert into DEPARTMENT (DEPARTMENT_ID, DEPARTMENT_NO, DEPARTMENT_NAME, LOCATION, VERSION)
    values (?, ?, ?, ?, ?)

The execute method may throw following exceptions:

* UniqueConstraintException: if an unique constraint is violated

Update statement
============================

For the specification of the where expression, see :ref:`criteria_where`.
The same rule is applied to update statements.

Update settings (Entityql, NativeSql)
-------------------------------------

We support the following settings:

* comment
* queryTimeout
* sqlLogType
* allowEmptyWhere
* batchSize

They are all optional.

You can apply them as follows:

.. code-block:: java

    Employee_ e = new Employee_();

    int count = nativeSql.update(e, settings -> {
      settings.setComment("update all");
      settings.setQueryTimeout(1000);
      settings.setSqlLogType(SqlLogType.RAW);
      settings.setAllowEmptyWhere(true);
      settings.setBatchSize(20);
    }).set(c -> {
      c.value(e.employeeName, "aaa");
    }).execute();

.. note::

    If you want to build a update statement without a WHERE clause,
    you have to enable the `allowEmptyWhere` setting.

Update statement (Entityql)
----------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    Employee employee = entityql.from(e).where(c -> c.eq(e.employeeId, 5)).fetchOne();
    employee.setEmployeeName("aaa");
    employee.setSalary(new Salary("2000"));

    Employee result = entityql.update(e, employee).execute();

The above query issues the following SQL statement:

.. code-block:: sql

    update EMPLOYEE set EMPLOYEE_NAME = ?, SALARY = ?, VERSION = ? + 1
    where EMPLOYEE_ID = ? and VERSION = ?

Batch Update is also supported:

.. code-block:: java

    Employee_ e = new Employee_();

    Employee employee = ...;
    Employee employee2 = ...;
    List<Employee> departments = Arrays.asList(employee, employee2);

    List<Employee> results = entityql.update(e, employees).execute();

The execute method may throw following exceptions:

* OptimisticLockException: if the entity has a version property and an update count is 0
* UniqueConstraintException: if an unique constraint is violated

Update statement (NativeSql)
----------------------------

.. code-block:: java

    Employee_ e = new Employee_();

    int count =
        nativeSql
            .update(e)
            .set(c -> c.value(e.departmentId, 3))
            .where(
                c -> {
                  c.isNotNull(e.managerId);
                  c.ge(e.salary, new Salary("2000"));
                })
            .execute();

The above query issues the following SQL statement:

.. code-block:: sql

    update EMPLOYEE t0_ set t0_.DEPARTMENT_ID = ?
    where t0_.MANAGER_ID is not null and t0_.SALARY >= ?

The execute method may throw following exceptions:

* UniqueConstraintException: if an unique constraint is violated

Tips
====

Execution in Dao (Entityql, NativeSql)
--------------------------------------

It is useful to execute DSLs in the default method of the Dao interface.
To get a ``config`` object, call ``Config.get(this)`` in the default method as follows:

.. code-block:: java

    @Dao
    public interface EmployeeDao {

      default Optional<Employee> selectById(Integer id) {
        Entityql entityql = new Entityql(Config.get(this));

        Employee_ e = new Employee_();
        return entityql.from(e).where(c -> c.eq(e.employeeId, id)).fetchOptional();
      }
    }

Debugging (Entityql, NativeSql)
-------------------------------

To know the SQL statement built by the DSLs, use the ``asSql`` method:

.. code-block:: java

    Department_ d = new Department_();

    Listable<Department> stmt = entityql.from(d).where(c -> c.eq(d.departmentName, "SALES"));

    Sql<?> sql = stmt.asSql();
    System.out.printf("Raw SQL      : %s\n", sql.getRawSql());
    System.out.printf("Formatted SQL: %s\n", sql.getFormattedSql());

The above code prints as follows:

.. code-block:: sh

    Raw SQL      : select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME, t0_.LOCATION, t0_.VERSION from DEPARTMENT t0_ where t0_.DEPARTMENT_NAME = ?
    Formatted SQL: select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME, t0_.LOCATION, t0_.VERSION from DEPARTMENT t0_ where t0_.DEPARTMENT_NAME = 'SALES'

The ``asSql`` method doesn't issue the SQL statement to your Database.
It only builds the SQL statement and return it as an ``Sql`` object.

You can also get the ``Sql`` object by calling the ``peek`` method.

.. code-block:: java

    Department_ d = new Department_();

    List<String> locations = nativeSql
            .from(d)
            .peek(System.out::println)
            .where(c -> c.eq(d.departmentName, "SALES"))
            .peek(System.out::println)
            .orderBy(c -> c.asc(d.location))
            .peek(sql -> System.out.println(sql.getFormattedSql()))
            .select(d.location)
            .peek(sql -> System.out.println(sql.getFormattedSql()))
            .fetch();

The above code prints as follows:

.. code-block:: sh

    select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME, t0_.LOCATION, t0_.VERSION from DEPARTMENT t0_
    select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME, t0_.LOCATION, t0_.VERSION from DEPARTMENT t0_ where t0_.DEPARTMENT_NAME = ?
    select t0_.DEPARTMENT_ID, t0_.DEPARTMENT_NO, t0_.DEPARTMENT_NAME, t0_.LOCATION, t0_.VERSION from DEPARTMENT t0_ where t0_.DEPARTMENT_NAME = 'SALES' order by t0_.LOCATION asc
    select t0_.LOCATION from DEPARTMENT t0_ where t0_.DEPARTMENT_NAME = 'SALES' order by t0_.LOCATION asc


Sample projects
===============

* `simple-examples <https://github.com/domaframework/simple-examples>`_
* `test-criteria <https://github.com/domaframework/doma/tree/master/test-criteria>`_

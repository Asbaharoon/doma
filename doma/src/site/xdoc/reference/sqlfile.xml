<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
	<properties>
		<title>SQLファイル</title>
	</properties>
	<body>
		<section name="目次">
			<ul>
				<li><a href="#概要">概要</a></li>
				<li><a href="#SQLファイルにマッピングするためのアノテーション">SQLファイルにマッピングするためのアノテーション</a></li>
				<li><a href="#SQLファイル">SQLファイル</a>
					<ul>
						<li><a href="#配置場所">配置場所</a></li>
						<li><a href="#ファイル名の形式">ファイル名の形式</a></li>
						<li><a href="#エンコーディング">エンコーディング</a></li>
					</ul>
				</li>
				<li><a href="#SQLコメント">SQLコメント</a>
					<ul>
						<li><a href="#バインド変数コメント">バインド変数コメント</a></li>
						<li><a href="#埋め込み変数コメント">埋め込み変数コメント</a></li>
						<li><a href="#条件コメント">条件コメント</a></li>
						<li><a href="#通常のブロックコメント">通常のブロックコメント</a></li>
						<li><a href="#通常の行コメント">通常の行コメント</a></li>
					</ul>
				</li>
				<li><a href="#式言語">式言語</a>
					<ul>
						<li><a href="#リテラル">リテラル</a></li>
						<li><a href="#比較演算子">比較演算子</a></li>
						<li><a href="#論理演算子">論理演算子</a></li>
						<li><a href="#算術演算子">算術演算子</a></li>
						<li><a href="#その他の演算子">その他の演算子</a></li>
						<li><a href="#インスタンスメソッドの呼び出し">インスタンスメソッドの呼び出し</a></li>
						<li><a href="#インスタンスフィールドへのアクセス">インスタンスフィールドへのアクセス</a></li>
						<li><a href="#staticメソッドの呼び出し">staticメソッドの呼び出し</a></li>
						<li><a href="#staticフィールドへのアクセス">staticフィールドへのアクセス</a></li>
						<li><a href="#組み込み関数の使用">組み込み関数の使用</a></li>
					</ul>
				</li>
			</ul>
		</section>
		<section name="概要">
			<p>
				SQLファイルは、SQL文を格納したテキストファイルで、Daoのメソッドにマッピングされます。
				SQLのブロックコメント(/* */)や行コメント(--)を使用することで、バインド変数や動的なSQLのための条件分岐を表現できます。
				SQLのツールでそのままそのSQLを実行できるように、バインド変数にはテスト用のデータを指定します。テスト用のデータは、実行時には使用されません。
				たとえば、SQLファイルには次のようなSQL文が格納されます。
			</p>
<source><![CDATA[select * from employee where employee_id = /*employeeId*/99]]></source>
			<p>
				ここでは、ブロックコメントで囲まれた <code>employeeId</code>がDaoインタフェースのメソッドのパラメータに対応し、
				直後の <code>99</code>はテスト用の条件になります。
				対応するDaoインタフェースのメソッドは次のとおりです。
			</p>
<source><![CDATA[Employee selectById(employeeId);]]></source>
		</section>
		<section name="SQLファイルにマッピングするためのアノテーション">
			<p>
				SQLファイルとDaoのメソッドのマッピングは次のアノテーションで示します。
			</p>
			<ul>
				<li>
					<a href="../apidocs/org/seasar/doma/Select.html"><code>@Select</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/Insert.html"><code>@Insert(sqlFile = true)</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/Update.html"><code>@Update(sqlFile = true)</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/Delete.html"><code>@Delete(sqlFile = true)</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/BatchInsert.html"><code>@BatchInsert(sqlFile = true)</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/BatchUpdate.html"><code>@BatchUpdate(sqlFile = true)</code></a>
				</li>
				<li>
					<a href="../apidocs/org/seasar/doma/BatchDelete.html"><code>@BatchDelete(sqlFile = true)</code></a>
				</li>
			</ul>
		</section>
		<section name="SQLファイル">
			<subsection name="配置場所">
				<p>
					SQLファイルはクラスパスが通った  <code>META-INF</code> ディレクトリ以下に配置しなければいけません。
				</p>
			</subsection>
			<subsection name="ファイル名の形式">
				<p>
					ファイル名は、次の形式でなければいけません。
				</p>
<source>META-INF/Dalのクラスの完全修飾名をディレクトリに変換したもの/Data Access Objectのメソッド名.sql</source>
				<p>
					例えば、 Daoのクラスが <code>aaa.bbb.EmployeeDao</code>で
					マッピングしたいメソッドが <code>selectById</code> の場合、パス名は次のようになります。
				</p>
<source>META-INF/aaa/bbb/EmployeeDao/selectById.sql</source>
				<p>
					複数のRDBMSに対応する必要があり特定のRDBMSでは別のSQLファイルを使いたい場合、
					<code>.sql</code> の前にハイフン区切りでRDBMS名を入れることで、優先的に使用するファイルを指示できます。
					たとえば、PostgreSQL専用のSQLファイルは次の名前にします。
				</p>
<source>META-INF/aaa/bbb/EmployeeDao/selectById-postgres.sql</source>
				<p>
					この場合、PostgreSQLを使用している場合に限り、<code>META-INF/aaa/bbb/EmployeeDao/selectById.sql</code> よりも
					<code>META-INF/aaa/bbb/EmployeeDao/selectById-postgres.sql</code> が優先的に使用されます。
				</p>
				<p>
					RDBMS名は、 <code>org.seasar.doma.jdbc.dialect.Dialect</code>の <code>getName</code>メソッドの値が使用されます。
				</p>
			</subsection>
			<subsection name="エンコーディング">
				<p>
					SQLファイルのエンコーディングはUTF-8でなければいけません。
				</p>
			</subsection>
		</section>
		<section name="SQLコメント">
			<p>
				Domaでは、SQLコメント中に式を記述することで、値のバインディングや条件分岐を行います。
				式を含みDomaに解釈されるSQLコメントを<strong>式コメント</strong>と呼びます。
			</p>
			<subsection name="バインド変数コメント">
				<p>
					バインド変数を示す式コメントをバインド変数コメントと呼びます。
					バインド変数は、<code>java.sql.PreparedStatement</code>を介してSQLに設定されます。
				</p>
				<p>
					バインド変数は/*～*/というブロックコメントで囲んで示します。
					バインド変数の名前はDaoインタフェースのメソッドのパラメータ名にマッピングされます。
					バインド変数コメントの直後にはテスト用データを指定する必要があります。
					テスト用データは、実行時には使用されません。
				</p>
				<h4><code>単一のパラメータ</code></h4>
				<p>
					Daoインタフェースのメソッドのパラメータが<a href="basic.html">基本型</a>もしくは<a href="domain.html">ドメインクラス</a>の場合について説明します。
					単一のパラメータは、1つのバインド変数コメントに対応します。
					Daoインタフェースのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source><![CDATA[List<Employee> selectById(Integer employeeId);]]></source>
<source><![CDATA[select * from employee where employee_id = /*employeeId*/99]]></source>
				<p>
					<code>/*employeeId*/</code>は、<code>/* employeeId */</code>のように空白を含めて記述することも可能です。
				</p>
				<h4><code>Listのパラメータ</code></h4>
				<p>
					Daoインタフェースのメソッドのパラメータが<a href="basic.html">基本型</a>もしくは<a href="domain.html">ドメインクラス</a>を要素とするjava.util.Listの場合について説明します。
					Listのパラメータは、IN句の1つのバインド変数コメントに対応しますが、複数の値をバインドできます。
					バインド変数コメントはINキーワードの直後に置き、バインド変数コメントの直後には括弧つきでテスト用データを指定します。
					テスト用データは、実行時には使用されません。
					Daoインタフェースのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source><![CDATA[List<Employee> selectByIdList(List<Integer> employeeIdList);]]></source>
<source><![CDATA[select * from employee where employee_id in /*employeeIdList*/(1,2,3)]]></source>
				<p>
					<code>/*employeeIdList*/</code>は、<code>/* employeeIdList */</code>のように空白を含めて記述することも可能です。
				</p>
				<h4><code>エンティティクラスのパラメータ</code></h4>
				<p>
					Daoインタフェースのメソッドのパラメータが<a href="entity.html">エンティティクラス</a>の場合について説明します。
					エンティティクラスのパラメータは、複数のバインド変数コメントに対応します。
					バインド変数コメントの中では、ドット（.）を使用しエンティティのフィールドにアクセスできます。
					Daoインタフェースのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source><![CDATA[List<Employee> selectByNameAndSalary(Employee employee);]]></source>
<source><![CDATA[select * from employee
where
employee_name = /*employee.employeeName*/'abc' 
and
salary = /*employee.salary*/1234]]></source>
				<p>
					<code>/*employee.employeeName*/</code>は、<code>/* employee.employeeName */</code>のように空白を含めて記述することも可能です。
				</p>
				<p>
					フィールドにアクセスする代わりに、publicなメソッドを呼び出すことも可能です。
				</p>
<source><![CDATA[select * from employee
where
salary = /*employee.getTaxedSalary()*/1234]]></source>
			</subsection>
			<subsection name="埋め込み変数コメント">
				<p>
					埋め込み変数を示す式コメントを埋め込み変数コメントと呼びます。
					埋め込み変数の値は、SQLを組み立てる際にSQLの一部として直接埋め込まれます。
					すなわち、SQLインジェクション対策に必要な値のエスケープはアプリケーションの責任になります。
					安全のため、埋め込み変数の一部にシングルクォテーション、セミコロン、行コメント、ブロックコメントを含めることは禁止しています。
				</p>
				<p>
					埋め込み変数は/*#～*/というブロックコメントで示します。埋め込み変数の名前はメソッドのパラメータ名にマッピングされます。
					埋め込み変数はORDER BY句など、SQLの一部をプログラムで組み立てたい場合に使用できます。
					Daoのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source><![CDATA[List<Employee> selectAll(BigDecimal salary, String orderyBy);]]></source>
<source><![CDATA[select * from employee where salary > /*salary*/100 /*#orderBy*/]]></source>
				<p>
					Daoの呼び出し例は次の通りです。
				</p>
<source><![CDATA[EmployeeDao dao = new EmployeeDaoImpl();
BigDecimal salary = new BigDecimal(1000);
String orderBy = "order by salary asc, employee_name";
List<Employee> list = dao.selectAll(salary, orderBy);]]></source>
				<p>
					発行されるSQLは次のようになります。
				</p>
<source><![CDATA[select * from employee where salary > ? order by salary asc, employee_name]]></source>
				<p>
					<code>/*#orderBy*/</code>は、<code>/*# orderBy */</code>のように空白を含めて記述することも可能です。
				</p>
			</subsection>
			<subsection name="条件コメント">
				<h4><code>if</code> と <code>end</code></h4>
				<p>
					条件分岐を示す式コメントを条件コメントと呼びます。
					構文は、<code>/*%if 条件*/ ～ /*%end*/</code> となります。
				</p>
<source><![CDATA[select * from employee where /*%if employeeId != null*/employee_id = /*employeeId*/99/*%end*/]]></source>
				<p>
					このSQL文は、 <code>employeeId</code>が <code>null</code>でない場合 次のような準備された文に変換されます。
				</p>
<source><![CDATA[select * from employee where employee_id = ?]]></source>
				<p>
					このSQL文は、 <code>employeeId</code>が<code>null</code>の場合に次のような準備された文に変換されます。
				</p>
<source><![CDATA[select * from employee]]></source>
				<h4><code>WHERE</code>や <code>HAVING</code>の自動除去</h4>
				<p>
					条件コメントを使用した場合、条件の前にあるWHEREやHAVINGについて、自動で出力の要/不要を判定します。
					たとえば、次のようなSQLで<code>employeeId</code>が <code>null</code>の場合、
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeId != null*/
    employee_id = /*employeeId*/99
/*%end*/]]></source>
				<p>
					<code>/*%if*/</code>の前の <code>where</code>は自動で除去されます。
				</p>
<source><![CDATA[select * from employee]]></source>
				<h4><code>AND</code>や <code>OR</code>の自動除去</h4>
				<p>
					条件コメントを使用した場合、条件の後ろにつづくANDやORについて、自動で出力の要/不要を判定します。
					たとえば、次のようなSQLで<code>employeeId</code>が <code>null</code>の場合、
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeId != null*/
    employee_id = /*employeeId*/99
/*%end*/
and employeeName like 's%']]></source>
				<p>
					<code>/*%end*/</code>の後ろの <code>and</code> は自動で除去されます。
				</p>
<source>select * from employee where employeeName like 's%'</source>
				<h4><code>elseif</code> と <code>else</code></h4>
				<p>
					<code>/*%if 条件*/</code> と <code>/*%end*/</code> の間では、
					行コメントを使用した <code>--elseif 条件--</code> や <code>--else</code> という構文も使用できます。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeId != null*/   employee_id = /*employeeId*/99
--elseif employeeId == 999-- department_id is null
--else                       employee_id is null
/*%end*/]]></source>
				<h4>ネストした条件コメント</h4>
				<p>
					条件コメントはネストさせることができます。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeId != null*/
  employee_id = /*employeeId*/99
  /*%if employeeName != null*/ 
    and employee_name = /*employeeName*/'hoge'
  /*%end*/
/*%end*/]]></source>
			</subsection>
			<subsection name="通常のブロックコメント">
				<p>
					<code>/*</code>の直後に続く3文字目が次のような値の場合、それは通常のブロックコメントだとみなされます。
				</p>
				<ul>
					<li>Javaの識別子の先頭で使用できない文字（ただし、空白、<code>%</code>、<code>#</code>、<code>@</code>、<code>"</code>、<code>'</code>は除く）</li>
				</ul>
				<p>
					たとえば、次の例はすべて通常のブロックコメントとみなされます。
				</p>
<source><![CDATA[/**～*/
/*+～*/
/*=～*/
/*:～*/
/*;～*/
/*(～*/
/*)～*/
/*&;～*/]]></source>
				<p>
					一方、次の例はすべて式コメントだとみなされます。
				</p>
<source>/* ～*/ ...--3文字目が空白であるため式コメントです。
/*a～*/ ...--3文字目がJavaの識別子の先頭で使用可能な文字であるため式コメントです。
/*$～*/ ...--3文字目がJavaの識別子の先頭で使用可能な文字であるため式コメントです。
/*%～*/ ...--3文字目が条件コメントを表す「<code>%</code>」であるため式コメントです。
/*#～*/ ...--3文字目が埋め込み変数コメントを表す「<code>#</code>」であるため式コメントです。
/*@～*/ ...--3文字目が組み込み関数もしくはクラス名を表す「<code>@</code>」であるため式コメントです。</source>
			</subsection>
			<subsection name="通常の行コメント">
				<p>
					<code>--</code>の直後に、<code>elseif</code>や<code>else</code>がつづかない場合、それは通常の行コメントだとみなされます。
				</p>
				<p>
					たとえば、次の例は通常の行コメントだとみなされます。
				</p>
<source>-- aaa</source>
				<p>
					一方、次の例はすべて式コメントだとみなされます。
				</p>
<source>--elseif ～ --
--else</source>
			</subsection>
		</section>
		<section name="式言語">
			<p>
				式コメントには式を記述できます。
				文法は、Javaとほとんど同じです。
				ただし、Javaで可能なことすべてができるわけではありません。
			</p>
			<subsection name="リテラル">
				<p>
					以下のリテラルが用意されています。
				</p>
				<table>
					<tr><th>リテラル</th><th>型</th></tr>
					<tr><td><code>null</code></td><td>void</td></tr>
					<tr><td><code>true</code></td><td>boolean</td></tr>
					<tr><td><code>false</code></td><td>boolean</td></tr>
					<tr><td><code>10</code></td><td>int</td></tr>
					<tr><td><code>10L</code></td><td>long</td></tr>
					<tr><td><code>0.123F</code></td><td>float</td></tr>
					<tr><td><code>0.123D</code></td><td>double</td></tr>
					<tr><td><code>0.123B</code></td><td>java.math.BigDecimal</td></tr>
					<tr><td><code>'a'</code></td><td>char</td></tr>
					<tr><td><code>"a"</code></td><td>String</td></tr>
				</table>
				<p>
					数値の型は、リテラルの最後に「L」や「F」などを付与して区別します。
					「L」や「F」などは大文字でなければいけません。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeName != null && employeeName.length() > 10 */
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="比較演算子">
				<p>
					以下の比較演算子を使用できます。
				</p>
				<table>
					<tr><th>比較演算子</th></tr>
					<tr><td><code>==</code></td></tr>
					<tr><td><code>!=</code></td></tr>
					<tr><td><code>&lt;</code></td></tr>
					<tr><td><code>&lt;=</code></td></tr>
					<tr><td><code>&gt;</code></td></tr>
					<tr><td><code>&gt;=</code></td></tr>
				</table>
				<p>
					比較演算子を利用するには、 被演算子が <code>java.lang.Comparable</code>を実装している必要があります。
				</p>
				<p>
					<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>では、
					非演算子に<code>null</code>リテラルを使用できません。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeName.indexOf("s") > -1 */
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="論理演算子">
				<p>
					以下の論理演算子を使用できます。
				</p>
				<table>
					<tr><th>論理演算子</th></tr>
					<tr><td><code>!</code></td></tr>
					<tr><td><code>&amp;&amp;</code></td></tr>
					<tr><td><code>||</code></td></tr>
				</table>
				<p>
					 括弧を使って、演算子が適用される優先度を制御できます。
				</p>
<source><![CDATA[select * from employee where 
/*%if (departmentId == null || managerId == null) and employee_name != null*/
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="算術演算子">
				<p>
					以下の算術演算子を使用できます。
				</p>
				<table>
					<tr><th>算術演算子</th></tr>
					<tr><td><code>+</code></td></tr>
					<tr><td><code>-</code></td></tr>
					<tr><td><code>*</code></td></tr>
					<tr><td><code>/</code></td></tr>
				</table>
				<p>
					 被演算子は数値型でなければいけません。
				</p>
<source><![CDATA[select * from employee where 
    salary = /*salary + 1000*/0]]></source>
			</subsection>
			<subsection name="その他の演算子">
				<p>
					<code>+</code>演算子を使って文字を連結できます。
				</p>
				<p>
					 被演算子は次のいずれかの型でなければいけません。
				</p>
				<ul>
					<li>java.lang.String</li>
					<li>java.lang.Character</li>
					<li>char</li>
				</ul>
<source><![CDATA[select * from employee where 
   employee_name like /*employeeName + "_"*/'smith']]></source>
			</subsection>
			<subsection name="インスタンスメソッドの呼び出し">
				<p>
					ドット（.）で区切ってメソッド名を指定することでインスタンスメソッドを実行可能です。
					実行可能なメソッドは、可視性が<code>public</code>なものだけに限られます。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeName.startsWith("s") */
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
				<p>
					引数がない場合は、メソッド名の後ろに()を指定します。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeName.length() > 10 */ 
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="インスタンスフィールドへのアクセス">
				<p>
					ドット（.）で区切ってフィールド名を指定することでインスタンスフィールドにアクセスできます。
					可視性はprivateであってもアクセス可能です。
				</p>
<source><![CDATA[select * from employee where 
    employee_name = /*employee.employeeName*/'smith']]></source>
			</subsection>
			<subsection name="staticメソッドの呼び出し">
				<p>
					<code>@</code>で囲まれたクラスの完全修飾名にメソッドを続けることでstaticメソッドを実行可能です。
					実行可能なメソッドは、可視性が<code>public</code>なものだけに限られます。
				</p>
<source><![CDATA[select * from employee where 
/*%if @java.util.regex.Pattern@matches("^[a-z]*$", employeeName) */
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="staticフィールドへのアクセス">
				<p>
					<code>@</code>で囲まれたクラスの完全修飾名にフィールドを続けることでstaticフィールドにアクセスできます。
					可視性はprivateであってもアクセス可能です。
				</p>
<source><![CDATA[select * from employee where 
/*%if employeeName.lenght() < @java.lang.Byte@MAX_VALUE */
    employee_name = /*employeeName*/'smith'
/*%end*/]]></source>
			</subsection>
			<subsection name="組み込み関数の使用">
				<p>
					組み込み関数は、主に、SQLにバインドする前にバインド変数の値を変更するためのユーティリティです。
				</p>
				<p>
					たとえば、likeで前方一致検索を行う場合に、次のように記述できます。
				</p>
<source><![CDATA[select * from employee where 
    employee_name like /*@startWith(employee.employeeName)*/'smith']]></source>
				<p>
					ここでは、<code>@startWith(employee.employeeName)</code> というように、
					<code>employee.employeeName</code> を <code>@startWith</code>関数に渡しています。
					組み込み関数の名前はすべて<code>@</code>で始まります。
					<code>employee.employeeName</code> の値が「ABC」である場合、
					SQLにバインディングされる値は「ABC%」となります。
					もし、<code>employee.employeeName</code> の値が「AB%C」というように「%」を含んでいる場合、
					「%」はデフォルトのエスケープシーケンスでエスケープされ、SQLにバインディングされる値は「AB\%C%」となります。
				</p>
				<p>
					使用可能な関数は以下のとおりです。デフォルトでは、いずれの関数も最初の引数に<code>null</code>を渡した場合、<code>null</code>を返します。
				</p>
				<table>
					<tr><th>戻り値の型</th><th>関数名とパラメータ</th><th>概要</th></tr>
					<tr><td><code>String</code></td><td><code>@startWith(String text)</code></td><td>前方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを後ろに付与した文字列です。エスケープにはデフォルトのエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>String</code></td><td><code>@startWith(String text, char escape)</code></td><td>前方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを後ろに付与した文字列です。エスケープは第2引数で指定したエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>String</code></td><td><code>@endWith(String text)</code></td><td>後方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを前に付与した文字列です。エスケープはデフォルトのエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>String</code></td><td><code>@endWith(String text, char escape)</code></td><td>後方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを前に付与した文字列です。エスケープは第2引数で指定したエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>String</code></td><td><code>@contain(String text)</code></td><td>前方後方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを前と後ろに付与した文字列です。エスケープはデフォルトのエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>String</code></td><td><code>@contain(String text, char escape)</code></td><td>前方後方一致検索を行うことを示します。戻り値は入力値をエスケープしワイルドカードを前と後ろに付与した文字列です。エスケープは第2引数で指定したエスケープ文字を用いて行われます。</td></tr>
					<tr><td><code>java.sql.Date</code></td><td><code>@roundDownTimePart(java.sql.Date date)</code></td><td>時刻部分を切り捨てることを示します。戻り値は時刻部分が切り捨てられた新しい日付です。</td></tr>
					<tr><td><code>java.sql.Timestamp</code></td><td><code>@roundDownTimePart(java.sql.Timestamp timestamp)</code></td><td>時刻部分を切り捨てることを示します。戻り値は時刻部分が切り捨てられた新しいタイムスタンプです。</td></tr>
					<tr><td><code>java.sql.Date</code></td><td><code>@roundUpTimePart(java.sql.Date date)</code></td><td>時刻部分を切り上げることを示します。戻り値は時刻部分が切り上げられた新しい日付です。</td></tr>
					<tr><td><code>java.sql.Timestamp</code></td><td><code>@roundUpTimePart(java.sql.Timestamp timestamp)</code></td><td>時刻部分を切り上げることを示します。戻り値は時刻部分が切り上げられた新しいタイムスタンプです。</td></tr>
				</table>
				<p>
					これらの関数は、<a href ="../apidocs/org/seasar/doma/expr/ExpressionFunctions.html"><code>org.seasar.doma.expr.ExpressionFunctions</code></a>のメソッドに対応しています。
				</p>
			</subsection>
		</section>
	</body>
</document>
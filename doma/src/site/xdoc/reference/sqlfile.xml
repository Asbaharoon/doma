<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
	<properties>
		<title>SQLファイル</title>
	</properties>
	<body>
		<section name="概要">
			<p>
				SQLファイルは、SQL文を格納したテキストファイルで、Daoのメソッドにマッピングされます。
				SQLのブロックコメント(/* */)や行コメント(--)を使用することで、バインド変数や動的なSQLのための条件分岐を表現できます。
				SQLのツールですぐにそのSQLを実行できるように、バインド変数にはテスト用のデータを指定できます。テスト用のデータは、実行時には使用されません。
				たとえば、SQLファイルには次のようなSQL文が格納されます。
			</p>
<source>select * from employee where employee_id = /*employeeId*/99</source>
			<p>
				ここでは、ブロックコメントで囲まれた <code>employeeId</code>がDaoのメソッドのパラメータに対応します。
				直後の <code>99</code>はテスト用の条件になります。
			</p>
		</section>
		<section name="SQLファイルにマッピングするためのアノテーション">
			<p>
				SQLファイルとDaoのメソッドのマッピングは次のアノテーションで示します。
			</p>
			<ul>
				<li>
					<code>@Select</code>
				</li>
				<li>
					<code>@Insert(sqlFile = true)</code>
				</li>
				<li>
					<code>@Update(sqlFile = true)</code>
				</li>
				<li>
					<code>@Delete(sqlFile = true)</code>
				</li>
				<li>
					<code>@BatchInsert(sqlFile = true)</code>
				</li>
				<li>
					<code>@BatchUpdate(sqlFile = true)</code>
				</li>
				<li>
					<code>@BatchDelete(sqlFile = true)</code>
				</li>
			</ul>
		</section>
		<section name="SQLファイル">
			<subsection name="配置場所">
				<p>
					SQLファイルはクラスパスが通った  <code>META-INF</code> ディレクトリ以下に配置しなければいけません。
				</p>
			</subsection>
			<subsection name="ファイル名の形式">
				<p>
					ファイル名は、次の形式でなければいけません。
				</p>
<source>META-INF/Dalのクラスの完全修飾名をディレクトリに変換したもの/Data Access Objectのメソッド名.sql</source>
				<p>
					例えば、 Daoのクラスが <code>aaa.bbb.EmployeeDao</code>で
					マッピングしたいメソッドが <code>selectById</code> の場合、パス名は次のようになります。
				</p>
<source>META-INF/aaa/bbb/EmployeeDao/selectById.sql</source>
				<p>
					複数のRDBMSに対応する必要があり特定のRDBMSでは別のSQLファイルを使いたい場合、
					<code>.sql</code> の前にRDBMS名を入れることで、優先的に使用するファイルを指示できます。
					たとえば、PostgreSQL専用のSQLファイルは次の名前にします。
				</p>
<source>META-INF/aaa/bbb/EmployeeDao/selectById_postgres.sql</source>
				<p>
					この場合、PostgreSQLを使用している場合に限り、<code>META-INF/aaa/bbb/EmployeeDao/selectById.sql</code> よりも
					<code>META-INF/aaa/bbb/EmployeeDao/selectById_postgres.sql</code> が優先的に使用されます。
				</p>
				<p>
					RDBMS名は、 <code>org.seasar.doma.jdbc.dialect.Dialect</code>の <code>getName</code>メソッドの値が使用されます。
				</p>
			</subsection>
			<subsection name="エンコーディング">
				<p>
					SQLファイルのエンコーディングはUTF-8でなければいけません。
				</p>
			</subsection>
		</section>
		<section name="SQLコメント">
			<subsection name="バインド変数コメント">
				<h4><code>1つのバインド変数</code></h4>
				<p>
					バインド変数はブロックコメントで囲んで示します。バインド変数の名前はメソッドのパラメータ名にマッピングされます。
					ブロックコメント直後のテスト用データは必須です。テスト用データは、実行時には使用されません。
					Daoのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source>List&lt;Employee&gt; selectById(Integer employeeId);</source>
<source>select * from employee where employee_id = /*employeeId*/99</source>
				<p>
					<code>/*employeeId*/</code>は、<code>/* employeeId */</code>のように空白を含めて記述することも可能です。
				</p>
				<h4><code>リストのバインド変数（IN句にバインドする場合）</code></h4>
				<p>
					IN句にバインドする場合は、INの直後にブロックコメントをおき、ブロックコメントの直後には括弧つきでテスト用データを指定します。テスト用データは、実行時には使用されません。
					Daoのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source>List&lt;Employee&gt; selectByIdList(List&lt;Integer&gt; employeeIdList);</source>
<source>select * from employee where employee_id in /*employeeIdList*/(1,2,3)</source>
				<h4><code>エンティティ型パラメータをバインド変数に利用する場合</code></h4>
				<p>
					メソッドでエンティティを渡す場合、バインド変数コメント内でドット（.）を使用することでエンティティのプロパティにアクセスできます。
					Daoのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source>List&lt;Employee&gt; selectById(Employee employee);</source>
<source>select * from employee where employee_id = /*employee.employeeId*/99</source>
			</subsection>
			<subsection name="埋め込み変数コメント">
				<p>
					埋め込み変数は/*#～*/というブロックコメントで示します。埋め込み変数の名前はメソッドのパラメータ名にマッピングされます。
					埋め込み変数はORDER BY句など、SQLの一部をプログラムで組み立てたい場合に使用できます。
					安全のため、埋め込み変数の一部にシングルクォテーション、セミコロン、ラインコメント、ブロックコメントを含めることは認められていません。
					シングルクォテーション以外のSQLインジェクション対策はアプリケーションの責任になります。
					Daoのメソッドと、対応するSQLの例は次のとおりです。
				</p>
<source>List&lt;Employee&gt; selectAll(BigDecimal salary, String orderyBy);</source>
<source>select * from employee where salary > /*salary*/100 /*#orderBy*/</source>
				<p>
					Daoの呼び出し例は次の通りです。
				</p>
<source>EmployeeDao dao = new EmployeeDaoImpl();
BigDecimal salary = new BigDecimal(1000);
String orderBy = "order by salary asc, employee_name";
List&lt;Employee&gt; list = dao.selectAll(salary, orderBy);</source>
				<p>
					発行されるSQLは次のようになります。
				</p>
<source>select * from employee where salary > ? order by salary asc, employee_name</source>
				<p>
					<code>/*#orderBy*/</code>は、<code>/*# orderBy */</code>のように空白を含めて記述することも可能です。
				</p>

			</subsection>
			<subsection name="条件コメント">
				<h4><code>if</code> と <code>end</code></h4>
				<p>
					条件によってSQLを組み立てる場合は、<code>/*%if 条件*/ ～ /*%end*/</code>という構文を使用できます。
				</p>
<source>select * from employee where /*%if employeeId != null*/employee_id = /*employeeId*/99/*%end*/</source>
				<p>
					このSQL文は、 <code>employeeId</code>が <code>null</code>でない場合 次のような準備された文に変換されます。
				</p>
<source>select * from employee where employee_id = ?</source>
				<p>
					このSQL文は、 <code>employeeId</code>  <code>null</code>の場合に次のような準備された文に変換されます。
				</p>
<source>select * from employee</source>
				<h4><code>WHERE</code>や <code>HAVING</code>の自動除去</h4>
				<p>
					条件コメントを使用した場合、条件の前にあるWHEREやHAVINGについて、自動で出力の要/不要を判定します。
					たとえば、次のようなSQLで<code>employeeId</code>が <code>null</code>の場合、
				</p>
<source>select * from employee where /*%if employeeId != null*/employee_id = /*employeeId*/99/*%end*/</source>
				<p>
					<code>/*%if*/</code>の前の <code>where</code>は自動で除去されます。
				</p>
<source>select * from employee</source>
				<h4><code>AND</code>や <code>OR</code>の自動除去</h4>
				<p>
					条件コメントを使用した場合、条件の後ろにつづくANDやORについて、自動で出力の要/不要を判定します。
					たとえば、次のようなSQLで<code>employeeId</code>が <code>null</code>の場合、
				</p>
<source>select * from employee where /*%if employeeId != null*/employee_id = /*employeeId*/99/*%end*/ and employeeName like 's%'</source>
				<p>
					<code>/*%end*/</code>の後ろの <code>and</code> は自動で除去されます。
				</p>
<source>select * from employee where employeeName like 's%'</source>
				<h4><code>elseif</code> と <code>else</code></h4>
				<p>
					<code>/*%if 条件*/</code> と <code>/*%end*/</code> の間では、
					行コメントを使用した <code>--elseif 条件--</code> や <code>--else</code> という構文も使用できます。
				</p>
<source>select * from employee where 
/*%if employeeId != null*/   employee_id = /*employeeId*/99
--elseif employeeId == 999-- department_id is null
--else                       employee_id is null
/*%end*/</source>
				<h4>ネストした条件コメント</h4>
				<p>
					条件コメントはネストさせることができます。
				</p>
<source>select * from employee where 
/*%if employeeId != null*/
  employee_id = /*employeeId*/99
  /*%if employeeName != null*/ 
    and employee_name = /*employeeName*/'hoge'
  /*%end*/
/*%end*/</source>
			</subsection>
			<subsection name="通常のブロックコメント">
				<p>
					<code>/*</code>の直後に、空白以外のJavaの変数で使用できない値が続く場合、それは通常のSQLコメントだとみなされます。
					ただし、条件コメントを示す <code>%</code>や
					埋め込みコメントを示す<code>#</code>がつづく場合は通常のコメントとみなされません。
				</p>
				<p>
					たとえば、次の例は通常のブロックコメントの使い方です。
				</p>
<source>/** aaa */</source>
<source>/*+aaa */</source>
				<p>
					次の例は通常のブロックコメントとみなされません。
				</p>
<source>/* id */</source>
<source>/*$aaa*/</source>
<source>/*%aaa*/</source>
<source>/*#aaa*/</source>
				<p>
					<code>/* id */</code>は空白が除去され<code>id</code>というバインド変数とみなされます。
					<code>/*$aaa*/</code>は<code>$aaa</code>というバインド変数とみなされます。
					<code>/*%aaa*/</code>は<code>%</code>で始まっているため条件コメントとして解釈されます（しかし、<code>if</code>でも<code>end</code>でもないためエラーとなります）。
					<code>/*#aaa*/</code>は<code>aaa</code>という埋め込み変数コメントとみなされます。
				</p>
			</subsection>
			<subsection name="通常の行コメント">
				<p>
					<code>--</code>の直後に、<code>elseif</code>や<code>else</code>がつづかない場合、それは通常のSQLコメントだとみなされます。
				</p>
				<p>
					たとえば、次の例は通常の行コメントの使い方です。
				</p>
<source>-- aaa</source>
			</subsection>
		</section>
		<section name="式言語">
			<p>
				条件コメントの <code>/*%if 条件*/</code> や、 <code>--elseif 条件--</code> の条件部には、式を記述できます。
			</p>
			<subsection name="定数">
				<p>
					次の定数が用意されています。
				</p>
				<table>
					<tr><td>定数</td><td>型</td></tr>
					<tr><td><code>null</code></td><td>void</td></tr>
					<tr><td><code>true</code></td><td>boolean</td></tr>
					<tr><td><code>false</code></td><td>boolean</td></tr>
					<tr><td><code>10</code></td><td>int</td></tr>
					<tr><td><code>10L</code></td><td>long</td></tr>
					<tr><td><code>0.123F</code></td><td>float</td></tr>
					<tr><td><code>0.123D</code></td><td>doubl</td></tr>
					<tr><td><code>0.123B</code></td><td>java.math.BigDecimal</td></tr>
					<tr><td><code>'a'</code></td><td>char</td></tr>
					<tr><td><code>"a"</code></td><td>String</td></tr>
				</table>
			</subsection>
			<subsection name="比較演算子">
				<p>
					以下の比較演算子を使用できます。
				</p>
				<table>
					<tr><td>比較演算子</td></tr>
					<tr><td><code>==</code></td></tr>
					<tr><td><code>!=</code></td></tr>
					<tr><td><code>&lt;</code></td></tr>
					<tr><td><code>&lt;=</code></td></tr>
					<tr><td><code>&gt;</code></td></tr>
					<tr><td><code>&gt;=</code></td></tr>
				</table>
				<p>
					<code>==</code> と <code>!=</code> 以外の比較演算子を利用するには、 被演算子が <code>java.lang.Comparable</code>を実装している必要があります。
				</p>
			</subsection>
			<subsection name="論理演算子">
				<p>
					以下の論理演算子を使用できます。
				</p>
				<table>
					<tr><td>論理演算子</td></tr>
					<tr><td><code>!</code></td></tr>
					<tr><td><code>&amp;&amp;</code></td></tr>
					<tr><td><code>||</code></td></tr>
				</table>
				<p>
					 括弧を使って、演算子が適用される対象を制御できます。
				</p>
<source>select * from employee where /*%if (departmentId == null || managerId == null) and employee_name != null*/ employee_name = /*employeeName*/'smith'/*%end*/</source>
			</subsection>
			<subsection name="算術演算子">
				<p>
					以下の算術演算子を使用できます。
				</p>
				<table>
					<tr><td>算術演算子</td></tr>
					<tr><td><code>+</code></td></tr>
					<tr><td><code>-</code></td></tr>
					<tr><td><code>*</code></td></tr>
					<tr><td><code>/</code></td></tr>
				</table>
				<p>
					 被演算子は数値型でなければいけません。
				</p>
			</subsection>
			<subsection name="メソッド呼び出し">
				<p>
					ドット（.）で区切ってメソッド名を指定することでメソッドを実行可能です。実行可能なメソッドは、可視性が<code>public</code>なものだけに限られます。
				</p>
<source>select * from employee where /*%if employeeName.startsWith("s") */ employee_name = /*employeeName*/'smith'/*%end*/</source>
				<p>
					引数がない場合は、メソッド名の後ろに()を指定します。
				</p>
<source>select * from employee where /*%if employeeName.length() > 10 */ employee_name = /*employeeName*/'smith'/*%end*/</source>
			</subsection>
			<subsection name="フィールドアクセス">
				<p>
					ドット（.）で区切ってフィールド名を指定することでフィールドにアクセスできます。アクセス可能なフィールドは可視性が非<code>private</code>なものです。
					<code>private</code>なフィールドにはアクセスできません。
				</p>
<source>select * from employee where /*%if employee.employeeName.startsWith("s") */ employee_name = /*employee.employeeName*/'smith'/*%end*/</source>
			</subsection>
		</section>
	</body>
</document>